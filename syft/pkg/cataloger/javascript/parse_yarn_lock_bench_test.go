package javascript

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"regexp"
	"strings"
	"testing"
)

func BenchmarkParseYarnV1LockFile(b *testing.B) {
	yarnV1Content, err := os.ReadFile("test-fixtures/yarn/yarn.lock")
	if err != nil {
		b.Fatalf("failed to read test fixture: %v", err)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		reader := bytes.NewReader(yarnV1Content)
		_, err := parseYarnV1LockFile(reader)
		if err != nil {
			b.Fatalf("failed to parse yarn v1 lockfile: %v", err)
		}
	}
}

func BenchmarkParseYarnV1LockFile_Old(b *testing.B) {
	yarnV1Content, err := os.ReadFile("test-fixtures/yarn/yarn.lock")
	if err != nil {
		b.Fatalf("failed to read test fixture: %v", err)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := parseYarnV1LockFile_Old(bytes.NewReader(yarnV1Content))
		if err != nil {
			b.Fatalf("failed to parse yarn v1 lockfile (old): %v", err)
		}
	}
}

func BenchmarkParseYarnV1LockFile_New(b *testing.B) {
	yarnV1Content, err := os.ReadFile("test-fixtures/yarn/yarn.lock")
	if err != nil {
		b.Fatalf("failed to read test fixture: %v", err)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := parseYarnV1LockFile(bytes.NewReader(yarnV1Content))
		if err != nil {
			b.Fatalf("failed to parse yarn v1 lockfile (new): %v", err)
		}
	}
}

func BenchmarkParseYarnV1LockFile_Large(b *testing.B) {
	content := generateLargeYarnV1Lockfile(1000)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		reader := strings.NewReader(content)
		_, err := parseYarnV1LockFile(reader)
		if err != nil {
			b.Fatalf("failed to parse yarn v1 lockfile: %v", err)
		}
	}
}

func BenchmarkParseYarnV1LockFile_Large_Old(b *testing.B) {
	content := generateLargeYarnV1Lockfile(1000)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := parseYarnV1LockFile_Old(strings.NewReader(content))
		if err != nil {
			b.Fatalf("failed to parse yarn v1 lockfile (old): %v", err)
		}
	}
}

func BenchmarkParseYarnV1LockFile_Large_New(b *testing.B) {
	content := generateLargeYarnV1Lockfile(1000)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := parseYarnV1LockFile(strings.NewReader(content))
		if err != nil {
			b.Fatalf("failed to parse yarn v1 lockfile (new): %v", err)
		}
	}
}

func BenchmarkParseYarnV1LockFile_VeryLarge(b *testing.B) {
	content := generateLargeYarnV1Lockfile(5000)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		reader := strings.NewReader(content)
		_, err := parseYarnV1LockFile(reader)
		if err != nil {
			b.Fatalf("failed to parse yarn v1 lockfile: %v", err)
		}
	}
}

func BenchmarkParseYarnV1LockFile_VeryLarge_Old(b *testing.B) {
	content := generateLargeYarnV1Lockfile(5000)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := parseYarnV1LockFile_Old(strings.NewReader(content))
		if err != nil {
			b.Fatalf("failed to parse yarn v1 lockfile (old): %v", err)
		}
	}
}

func BenchmarkParseYarnV1LockFile_VeryLarge_New(b *testing.B) {
	content := generateLargeYarnV1Lockfile(5000)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := parseYarnV1LockFile(strings.NewReader(content))
		if err != nil {
			b.Fatalf("failed to parse yarn v1 lockfile (new): %v", err)
		}
	}
}

func BenchmarkParseYarnV1LockFile_Memory(b *testing.B) {
	content := generateLargeYarnV1Lockfile(5000)

	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		reader := strings.NewReader(content)
		_, err := parseYarnV1LockFile(reader)
		if err != nil {
			b.Fatalf("failed to parse yarn v1 lockfile: %v", err)
		}
	}
}

func generateLargeYarnV1Lockfile(numPackages int) string {
	var sb strings.Builder
	sb.WriteString("# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n")
	sb.WriteString("# yarn lockfile v1\n\n")

	for i := 0; i < numPackages; i++ {
		escapedName := fmt.Sprintf("\"package-%d@^1.0.0\":", i)
		version := fmt.Sprintf("1.0.%d", i)

		sb.WriteString(escapedName)
		sb.WriteString("\n")
		sb.WriteString(fmt.Sprintf("  version \"%s\"\n", version))
		sb.WriteString(fmt.Sprintf("  resolved \"https://registry.yarnpkg.com/package-%d/-/package-%d-%s.tgz#1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\"\n", i, i, version))
		sb.WriteString(fmt.Sprintf("  integrity sha512-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n"))
		sb.WriteString("\n")
	}

	return sb.String()
}

func parseYarnV1LockFile_Old(reader io.Reader) ([]yarnPackage, error) {
	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, err
	}

	re := regexp.MustCompile(`\r?\n`)
	lines := re.Split(string(data), -1)

	var pkgs []yarnPackage
	var pkg = yarnPackage{}
	seenPkgs := make(map[string]struct{})
	dependencies := make(map[string]string)

	for _, line := range lines {
		if strings.HasPrefix(line, "#") {
			continue
		}
		if len(line) == 0 && len(pkg.Name) > 0 {
			key := pkg.Name + "@" + pkg.Version
			if _, seen := seenPkgs[key]; !seen {
				pkg.Dependencies = dependencies
				pkgs = append(pkgs, pkg)
				seenPkgs[key] = struct{}{}
				dependencies = make(map[string]string)
				pkg = yarnPackage{}
			}
			continue
		}
		if !strings.HasPrefix(line, " ") {
			pkg.Name = findPackageName(line)
			continue
		}
		if strings.HasPrefix(line, "  ") && !strings.HasPrefix(line, "    ") {
			line = strings.Trim(line, " ")
			array := strings.Split(line, " ")
			switch array[0] {
			case "version":
				pkg.Version = strings.Trim(array[1], "\"")
			case "resolved":
				name, version, resolved := findResolvedPackageAndVersion(line)
				if name != "" && version != "" && resolved != "" {
					pkg.Name = name
					pkg.Version = version
					pkg.Resolved = resolved
				} else {
					pkg.Resolved = strings.Trim(array[1], "\"")
				}
			case "integrity":
				pkg.Integrity = strings.Trim(array[1], "\"")
			}
			continue
		}
		if strings.HasPrefix(line, "    ") {
			line = strings.Trim(line, " ")
			array := strings.Split(line, " ")
			dependencyName := strings.Trim(array[0], "\"")
			dependencyVersion := strings.Trim(array[1], "\"")
			dependencies[dependencyName] = dependencyVersion
		}
	}

	if len(pkg.Name) > 0 {
		key := pkg.Name + "@" + pkg.Version
		if _, seen := seenPkgs[key]; !seen {
			pkg.Dependencies = dependencies
			pkgs = append(pkgs, pkg)
			seenPkgs[key] = struct{}{}
		}
	}

	return pkgs, nil
}
